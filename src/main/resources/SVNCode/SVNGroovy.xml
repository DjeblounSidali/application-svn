<?xml version="1.0" encoding="UTF-8"?>

<xwikidoc>
<web>SVNCode</web>
<name>SVNGroovy</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>XWiki.LudovicDubost</creator>
<author>XWiki.LudovicDubost</author>
<customClass></customClass>
<contentAuthor>XWiki.LudovicDubost</contentAuthor>
<creationDate>1270882076000</creationDate>
<date>1271718580000</date>
<contentUpdateDate>1271718580000</contentUpdateDate>
<version>36.1</version>
<title></title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<object>
<class>
<name>XWiki.TagClass</name>
<customClass></customClass>
<customMapping></customMapping>
<defaultViewSheet></defaultViewSheet>
<defaultEditSheet></defaultEditSheet>
<defaultWeb></defaultWeb>
<nameField></nameField>
<validationScript></validationScript>
<tags>
<cache>0</cache>
<displayType>checkbox</displayType>
<multiSelect>1</multiSelect>
<name>tags</name>
<number>1</number>
<prettyName>Tags</prettyName>
<relationalStorage>1</relationalStorage>
<separator> </separator>
<separators> ,|</separators>
<size>30</size>
<unmodifiable>0</unmodifiable>
<values></values>
<classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
</tags>
</class>
<name>SVNCode.SVNGroovy</name>
<number>0</number>
<className>XWiki.TagClass</className>
<guid>e74e9501-16d5-4622-a16c-55bb96ac61e1</guid>
<property>
<tags/>
</property>
</object>
<content>
import java.util.Collection;
import java.util.Iterator;
import org.apache.commons.lang.StringUtils;
import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();

        def currentPageData = new HashMap();
        def pagesBySpace = new HashMap();

        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new spaces: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;&amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new pages: ${filePath}")         
           } else {
                debug("Adding to updated pages: ${filePath}")         
                currentPageData.put(filePath, getFileContent(space, page, language))
           }

           def pageList = pagesBySpace.get(space);
           if (pageList==null) {
              pageList = new ArrayList();
              pagesBySpace.put(space, pageList);
           }
           pageList.add(pagedoc);
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         /*
          * Always called first. Opens the current root directory. It  means  all
          * modifications will be applied to this directory until  a  next  entry
          * (located inside the root) is opened/added.
          * 
          * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
          * irrelevant)
          */
         editor.openRoot(-1);

         for (space in pagesBySpace.keySet()) {
           // start by creating the space if necessary and open it if not
           /*
            * Adds a new directory (in this  case - to the  root  directory  for 
            * which the SVNRepository was  created). 
            * Since this moment all changes will be applied to this new  directory.
            * 
            * dirPath is relative to the root directory.
            * 
            * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
            * (the 3rd) parameter is set to  -1  since  the  directory is not added 
            * with history (is not copied, in other words).
            */
            if (newSpaces.contains(space)) {      
             editor.addDir(space, null, -1);
            } else {
             editor.openDir(space, -1);
            }

            // loop on each page
            for (pagedoc in pagesBySpace.get(space)) {  
              def page = pagedoc.getName();
              def language = pagedoc.getLanguage();

              // get page path
              def filePath = space + "/" + page;
              if (language!=null&amp;&amp;language!="")
                  filePath += "." + language;
              filePath += ".xml"

              def newData = pagedoc.document.toFullXML(context.getContext()).getBytes();

              if (newPages.contains(filePath)) {
                /*
                 * Adds a new file to the just added  directory. The  file  path is also 
                 * defined as relative to the root directory.
                 *
                 * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
                 * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
                 * history.
                 */
                 editor.addFile(filePath, null, -1);

                /*
                 * The next steps are directed to applying delta to the  file  (that  is 
                 * the full contents of the file in this case).
                 */
                editor.applyTextDelta(filePath, null);
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, using 'base' 
                 * data will result in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(newData), editor, true);

                /*
                 * Closes the new added file.
                 */
                editor.closeFile(filePath, checksum);
              } else {
                def oldData = currentPageData.get(filePath);

                /*
                 * Opens the file added in the previous commit.
                 * 
                 * filePath is also defined as a relative path to the root directory.
                 */
                editor.openFile(filePath, -1);
        
                /*
                 * The next steps are directed to applying and writing the file delta.
                 */
                editor.applyTextDelta(filePath, null);
        
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, here we've got 'base' 
                 * data, what in case of larger files results in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

                 /*
                 * Closes the file.
                 */
                editor.closeFile(filePath, checksum);
              }
            }

            // close the space
            editor.closeDir();
         }

         // close root dir
         editor.closeDir();
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir, boolean closeDir, boolean closeRootDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        if (closeDir)
         editor.closeDir();

        /*
         * Closes the root directory.
         */
        if (closeRootDir)
         editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String spaces) {
        def changedList = new ArrayList();
        def sspaces = StringUtils.join(StringUtils.split(spaces," ,"), "','");
        def sql = "select doc.fullName from XWikiDocument as doc where doc.space in ('${sspaces}')";
        debug("Searching for ${sql}");
        def list = xwiki.search(sql)
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

</content><versions>head	36.1;
access;
symbols;
locks; strict;
comment	@# @;


36.1
date	2010.04.19.23.09.40;	author XWiki_2ELudovicDubost;	state full;
branches;
next	35.1;

35.1
date	2010.04.19.18.26.35;	author XWiki_2ELudovicDubost;	state full;
branches;
next	34.1;

34.1
date	2010.04.19.18.25.41;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	33.1;

33.1
date	2010.04.19.18.25.04;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	32.1;

32.1
date	2010.04.19.18.24.43;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	31.1;

31.1
date	2010.04.19.18.24.12;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	30.1;

30.1
date	2010.04.19.18.22.58;	author XWiki_2ELudovicDubost;	state full;
branches;
next	29.1;

29.1
date	2010.04.19.17.56.03;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	28.1;

28.1
date	2010.04.19.17.36.32;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	27.1;

27.1
date	2010.04.19.17.35.31;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	26.1;

26.1
date	2010.04.12.17.16.31;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	25.1;

25.1
date	2010.04.12.17.15.53;	author XWiki_2ELudovicDubost;	state full;
branches;
next	24.1;

24.1
date	2010.04.12.17.10.36;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	23.1;

23.1
date	2010.04.12.17.09.27;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	22.1;

22.1
date	2010.04.12.17.08.21;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	21.1;

21.1
date	2010.04.12.17.04.59;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	20.1;

20.1
date	2010.04.12.17.03.36;	author XWiki_2ELudovicDubost;	state full;
branches;
next	19.1;

19.1
date	2010.04.12.17.01.25;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	18.1;

18.1
date	2010.04.12.17.00.24;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	17.1;

17.1
date	2010.04.12.16.58.10;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	16.1;

16.1
date	2010.04.12.16.51.19;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	15.1;

15.1
date	2010.04.12.16.50.48;	author XWiki_2ELudovicDubost;	state full;
branches;
next	14.1;

14.1
date	2010.04.12.16.50.25;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	13.1;

13.1
date	2010.04.12.16.49.58;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	12.1;

12.1
date	2010.04.12.16.46.20;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	11.1;

11.1
date	2010.04.12.16.45.23;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	10.1;

10.1
date	2010.04.12.16.42.43;	author XWiki_2ELudovicDubost;	state full;
branches;
next	9.1;

9.1
date	2010.04.12.15.40.18;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	8.1;

8.1
date	2010.04.12.15.21.12;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	7.1;

7.1
date	2010.04.12.15.20.29;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	6.1;

6.1
date	2010.04.12.15.07.04;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	5.1;

5.1
date	2010.04.12.15.05.41;	author XWiki_2ELudovicDubost;	state full;
branches;
next	4.1;

4.1
date	2010.04.12.15.04.44;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	3.1;

3.1
date	2010.04.10.07.00.39;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	2.1;

2.1
date	2010.04.10.06.57.36;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	1.1;

1.1
date	2010.04.10.06.50.56;	author XWiki_2ELudovicDubost;	state diff;
branches;
next	;


desc
@@


36.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271718580000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271718580000&lt;/contentUpdateDate&gt;
&lt;version&gt;36.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;
import org.apache.commons.lang.StringUtils;
import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();

        def currentPageData = new HashMap();
        def pagesBySpace = new HashMap();

        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new spaces: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new pages: ${filePath}")         
           } else {
                debug("Adding to updated pages: ${filePath}")         
                currentPageData.put(filePath, getFileContent(space, page, language))
           }

           def pageList = pagesBySpace.get(space);
           if (pageList==null) {
              pageList = new ArrayList();
              pagesBySpace.put(space, pageList);
           }
           pageList.add(pagedoc);
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         /*
          * Always called first. Opens the current root directory. It  means  all
          * modifications will be applied to this directory until  a  next  entry
          * (located inside the root) is opened/added.
          * 
          * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
          * irrelevant)
          */
         editor.openRoot(-1);

         for (space in pagesBySpace.keySet()) {
           // start by creating the space if necessary and open it if not
           /*
            * Adds a new directory (in this  case - to the  root  directory  for 
            * which the SVNRepository was  created). 
            * Since this moment all changes will be applied to this new  directory.
            * 
            * dirPath is relative to the root directory.
            * 
            * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
            * (the 3rd) parameter is set to  -1  since  the  directory is not added 
            * with history (is not copied, in other words).
            */
            if (newSpaces.contains(space)) {      
             editor.addDir(space, null, -1);
            } else {
             editor.openDir(space, -1);
            }

            // loop on each page
            for (pagedoc in pagesBySpace.get(space)) {  
              def page = pagedoc.getName();
              def language = pagedoc.getLanguage();

              // get page path
              def filePath = space + "/" + page;
              if (language!=null&amp;amp;&amp;amp;language!="")
                  filePath += "." + language;
              filePath += ".xml"

              def newData = pagedoc.document.toFullXML(context.getContext()).getBytes();

              if (newPages.contains(filePath)) {
                /*
                 * Adds a new file to the just added  directory. The  file  path is also 
                 * defined as relative to the root directory.
                 *
                 * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
                 * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
                 * history.
                 */
                 editor.addFile(filePath, null, -1);

                /*
                 * The next steps are directed to applying delta to the  file  (that  is 
                 * the full contents of the file in this case).
                 */
                editor.applyTextDelta(filePath, null);
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, using 'base' 
                 * data will result in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(newData), editor, true);

                /*
                 * Closes the new added file.
                 */
                editor.closeFile(filePath, checksum);
              } else {
                def oldData = currentPageData.get(filePath);

                /*
                 * Opens the file added in the previous commit.
                 * 
                 * filePath is also defined as a relative path to the root directory.
                 */
                editor.openFile(filePath, -1);
        
                /*
                 * The next steps are directed to applying and writing the file delta.
                 */
                editor.applyTextDelta(filePath, null);
        
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, here we've got 'base' 
                 * data, what in case of larger files results in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

                 /*
                 * Closes the file.
                 */
                editor.closeFile(filePath, checksum);
              }
            }

            // close the space
            editor.closeDir();
         }

         // close root dir
         editor.closeDir();
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir, boolean closeDir, boolean closeRootDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        if (closeDir)
         editor.closeDir();

        /*
         * Closes the root directory.
         */
        if (closeRootDir)
         editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String spaces) {
        def changedList = new ArrayList();
        def sspaces = StringUtils.join(StringUtils.split(spaces," ,"), "','");
        def sql = "select doc.fullName from XWikiDocument as doc where doc.space in ('${sspaces}')";
        debug("Searching for ${sql}");
        def list = xwiki.search(sql)
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


35.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271701595000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701595000&lt;/contentUpdateDate&gt;
&lt;version&gt;35.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;
import org.apache.commons.lang.StringUtils;
import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();

        def currentPageData = new HashMap();
        def pagesBySpace = new HashMap();

        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new spaces: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new pages: ${filePath}")         
           } else {
                debug("Adding to updated pages: ${filePath}")         
                currentPageData.put(filePath, getFileContent(space, page, language))
           }

           def pageList = pagesBySpace.get(space);
           if (pageList==null) {
              pageList = new ArrayList();
              pagesBySpace.put(space, pageList);
           }
           pageList.add(pagedoc);
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         /*
          * Always called first. Opens the current root directory. It  means  all
          * modifications will be applied to this directory until  a  next  entry
          * (located inside the root) is opened/added.
          * 
          * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
          * irrelevant)
          */
         editor.openRoot(-1);

         for (space in pagesBySpace.keySet()) {
           // start by creating the space if necessary and open it if not
           /*
            * Adds a new directory (in this  case - to the  root  directory  for 
            * which the SVNRepository was  created). 
            * Since this moment all changes will be applied to this new  directory.
            * 
            * dirPath is relative to the root directory.
            * 
            * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
            * (the 3rd) parameter is set to  -1  since  the  directory is not added 
            * with history (is not copied, in other words).
            */
            if (newSpaces.contains(space)) {      
             editor.addDir(space, null, -1);
            } else {
             editor.openDir(space, -1);
            }

            // loop on each page
            for (pagedoc in pagesBySpace.get(space)) {  
              def page = pagedoc.getName();
              def language = pagedoc.getLanguage();

              // get page path
              def filePath = space + "/" + page;
              if (language!=null&amp;amp;&amp;amp;language!="")
                  filePath += "." + language;
              filePath += ".xml"

              def newData = pagedoc.document.toFullXML(context.getContext()).getBytes();

              if (newPages.contains(filePath)) {
                /*
                 * Adds a new file to the just added  directory. The  file  path is also 
                 * defined as relative to the root directory.
                 *
                 * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
                 * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
                 * history.
                 */
                 editor.addFile(filePath, null, -1);

                /*
                 * The next steps are directed to applying delta to the  file  (that  is 
                 * the full contents of the file in this case).
                 */
                editor.applyTextDelta(filePath, null);
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, using 'base' 
                 * data will result in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(newData), editor, true);

                /*
                 * Closes the new added file.
                 */
                editor.closeFile(filePath, checksum);
              } else {
                def oldData = currentPageData.get(filePath);

                /*
                 * Opens the file added in the previous commit.
                 * 
                 * filePath is also defined as a relative path to the root directory.
                 */
                editor.openFile(filePath, -1);
        
                /*
                 * The next steps are directed to applying and writing the file delta.
                 */
                editor.applyTextDelta(filePath, null);
        
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, here we've got 'base' 
                 * data, what in case of larger files results in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

                 /*
                 * Closes the file.
                 */
                editor.closeFile(filePath, checksum);
              }
            }

            // close the space
            editor.closeDir();
         }

         // close root dir
         editor.closeDir();
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir, boolean closeDir, boolean closeRootDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        if (closeDir)
         editor.closeDir();

        /*
         * Closes the root directory.
         */
        if (closeRootDir)
         editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String spaces) {
        def changedList = new ArrayList();
        def sspaces = StringUtils.join(StringUtils.split(spaces," ,"), "','");
        def sql = "where doc.space in ('${sspaces}')";
        debug("Searching for ${sql}");
        def list = xwiki.searchDocuments(sql)
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


34.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271701541000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701541000&lt;/contentUpdateDate&gt;
&lt;version&gt;34.1&lt;/version&gt;
d755 1
a755 1
        def sspaces = StringUtils.join(spaces, "','");
@


33.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271701504000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701504000&lt;/contentUpdateDate&gt;
&lt;version&gt;33.1&lt;/version&gt;
d756 3
a758 1
        def list = xwiki.searchDocuments("where doc.space in ('${sspaces}')")
@


32.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271701483000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701483000&lt;/contentUpdateDate&gt;
&lt;version&gt;32.1&lt;/version&gt;
d63 1
a63 1
import org.apache.commons.StringUtils;
@


31.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271701452000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701452000&lt;/contentUpdateDate&gt;
&lt;version&gt;31.1&lt;/version&gt;
d63 1
a63 1

@


30.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271701378000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271701378000&lt;/contentUpdateDate&gt;
&lt;version&gt;30.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;

import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();

        def currentPageData = new HashMap();
        def pagesBySpace = new HashMap();

        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new spaces: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new pages: ${filePath}")         
           } else {
                debug("Adding to updated pages: ${filePath}")         
                currentPageData.put(filePath, getFileContent(space, page, language))
           }

           def pageList = pagesBySpace.get(space);
           if (pageList==null) {
              pageList = new ArrayList();
              pagesBySpace.put(space, pageList);
           }
           pageList.add(pagedoc);
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         /*
          * Always called first. Opens the current root directory. It  means  all
          * modifications will be applied to this directory until  a  next  entry
          * (located inside the root) is opened/added.
          * 
          * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
          * irrelevant)
          */
         editor.openRoot(-1);

         for (space in pagesBySpace.keySet()) {
           // start by creating the space if necessary and open it if not
           /*
            * Adds a new directory (in this  case - to the  root  directory  for 
            * which the SVNRepository was  created). 
            * Since this moment all changes will be applied to this new  directory.
            * 
            * dirPath is relative to the root directory.
            * 
            * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
            * (the 3rd) parameter is set to  -1  since  the  directory is not added 
            * with history (is not copied, in other words).
            */
            if (newSpaces.contains(space)) {      
             editor.addDir(space, null, -1);
            } else {
             editor.openDir(space, -1);
            }

            // loop on each page
            for (pagedoc in pagesBySpace.get(space)) {  
              def page = pagedoc.getName();
              def language = pagedoc.getLanguage();

              // get page path
              def filePath = space + "/" + page;
              if (language!=null&amp;amp;&amp;amp;language!="")
                  filePath += "." + language;
              filePath += ".xml"

              def newData = pagedoc.document.toFullXML(context.getContext()).getBytes();

              if (newPages.contains(filePath)) {
                /*
                 * Adds a new file to the just added  directory. The  file  path is also 
                 * defined as relative to the root directory.
                 *
                 * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
                 * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
                 * history.
                 */
                 editor.addFile(filePath, null, -1);

                /*
                 * The next steps are directed to applying delta to the  file  (that  is 
                 * the full contents of the file in this case).
                 */
                editor.applyTextDelta(filePath, null);
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, using 'base' 
                 * data will result in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(newData), editor, true);

                /*
                 * Closes the new added file.
                 */
                editor.closeFile(filePath, checksum);
              } else {
                def oldData = currentPageData.get(filePath);

                /*
                 * Opens the file added in the previous commit.
                 * 
                 * filePath is also defined as a relative path to the root directory.
                 */
                editor.openFile(filePath, -1);
        
                /*
                 * The next steps are directed to applying and writing the file delta.
                 */
                editor.applyTextDelta(filePath, null);
        
                /*
                 * Use delta generator utility class to generate and send delta
                 * 
                 * Note that you may use only 'target' data to generate delta when there is no 
                 * access to the 'base' (previous) version of the file. However, here we've got 'base' 
                 * data, what in case of larger files results in smaller network overhead.
                 * 
                 * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
                 * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
                 * Number of diff windows depends on the file size. 
                 *  
                 */
                SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
                String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

                 /*
                 * Closes the file.
                 */
                editor.closeFile(filePath, checksum);
              }
            }

            // close the space
            editor.closeDir();
         }

         // close root dir
         editor.closeDir();
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir, boolean closeDir, boolean closeRootDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        if (closeDir)
         editor.closeDir();

        /*
         * Closes the root directory.
         */
        if (closeRootDir)
         editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String spaces) {
        def changedList = new ArrayList();
        def list = xwiki.searchDocuments("where doc.space in ('${spaces.join("','")}')")
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


29.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271699763000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271699763000&lt;/contentUpdateDate&gt;
&lt;version&gt;29.1&lt;/version&gt;
d753 1
a753 1
    public getChangedPages(String space) {
d755 1
a755 1
        def list = xwiki.searchDocuments("where doc.space='${space}'")
@


28.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271698592000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271698592000&lt;/contentUpdateDate&gt;
&lt;version&gt;28.1&lt;/version&gt;
d406 1
a406 1
            if (newSpaces.get(space)) {      
@


27.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271698531000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271698531000&lt;/contentUpdateDate&gt;
&lt;version&gt;27.1&lt;/version&gt;
d393 1
a393 1
         for (space in pagesBySpace.keys()) {
@


26.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271092591000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271092591000&lt;/contentUpdateDate&gt;
&lt;version&gt;26.1&lt;/version&gt;
a337 1
        def newSpaces2 = new ArrayList();
d339 1
d341 2
d353 1
a353 1
                debug("Adding to new space: ${space}")         
d365 1
a365 1
                debug("Adding to new page: ${filePath}")         
d367 1
d370 7
d383 9
a391 13
         for (pagename in pagelist) {
           pagename2 = pagename;
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           def createDir = false;
           if (newSpaces.contains(space)) {
               createDir = true;  
               newSpaces2.add(space);    
               debug("ready to create space ${space}")        
           }  
           def xml = pagedoc.document.toFullXML(context.getContext())
d393 18
a410 5
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
            filePath += "." + language;
           filePath += ".xml"
d412 87
a498 11
           def newPage = newPages.contains(filePath);
           if (newPage) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, false, false)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, currentPageData.get(filePath), xml.getBytes())
           }
d500 3
a515 2
              editor.closeDir();
              editor.closeDir();
@


25.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271092553000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271092553000&lt;/contentUpdateDate&gt;
&lt;version&gt;25.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;

import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newSpaces2 = new ArrayList();
        def newPages = new ArrayList();
        def currentPageData = new HashMap();
        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new space: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new page: ${filePath}")         
           } else {
                currentPageData.put(filePath, getFileContent(space, page, language))
           }
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         for (pagename in pagelist) {
           pagename2 = pagename;
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           def createDir = false;
           if (newSpaces.contains(space)) {
               createDir = true;  
               newSpaces2.add(space);    
               debug("ready to create space ${space}")        
           }  
           def xml = pagedoc.document.toFullXML(context.getContext())

           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
            filePath += "." + language;
           filePath += ".xml"

           def newPage = newPages.contains(filePath);
           if (newPage) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, false, false)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, currentPageData.get(filePath), xml.getBytes())
           }
         }
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              editor.closeDir();
              editor.closeDir();
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir, boolean closeDir boolean closeRootDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        if (closeDir)
         editor.closeDir();

        /*
         * Closes the root directory.
         */
        if (closeRootDir)
         editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String space) {
        def changedList = new ArrayList();
        def list = xwiki.searchDocuments("where doc.space='${space}'")
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


24.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271092236000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271092236000&lt;/contentUpdateDate&gt;
&lt;version&gt;24.1&lt;/version&gt;
d397 1
a397 1
             addFile(editor, space, filePath, xml.getBytes(), createDir)
d418 2
d456 1
a456 1
             addFile(editor, space, filePath, xml.getBytes(), createDir)
d495 1
a495 1
            String filePath, byte[] data, boolean createDir) throws SVNException {
d557 3
a559 1
        editor.closeDir();
d563 2
a564 1
        editor.closeDir();
@


23.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271092167000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271092167000&lt;/contentUpdateDate&gt;
&lt;version&gt;23.1&lt;/version&gt;
d380 1
a380 1
           if (newSpaces.contains(space) &amp;amp;&amp;amp; !newSpaces2.contains(space)) {
@


22.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271092101000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271092101000&lt;/contentUpdateDate&gt;
&lt;version&gt;22.1&lt;/version&gt;
d396 1
d401 1
@


21.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091899000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091899000&lt;/contentUpdateDate&gt;
&lt;version&gt;21.1&lt;/version&gt;
d451 1
d456 1
@


20.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271091816000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091816000&lt;/contentUpdateDate&gt;
&lt;version&gt;20.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;

import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();
        def currentPageData = new HashMap();
        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE) {
                newSpaces.add(space);   
                debug("Adding to new space: ${space}")         
               }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE) {
                newPages.add(filePath);                 
                debug("Adding to new page: ${filePath}")         
           } else {
                currentPageData.put(filePath, getFileContent(space, page, language))
           }
        }

        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;

        try {
         for (pagename in pagelist) {
           pagename2 = pagename;
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           def createDir = false;
           if (newSpaces.contains(space)) {
               createDir = true;  
               newSpaces.remove(space);            
           }  
           def xml = pagedoc.document.toFullXML(context.getContext())

           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
            filePath += "." + language;
           filePath += ".xml"

           def newPage = newPages.contains(filePath);
           if (newPage) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, currentPageData.get(filePath), xml.getBytes())
           }
         }
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        editor.closeDir();
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String space) {
        def changedList = new ArrayList();
        def list = xwiki.searchDocuments("where doc.space='${space}'")
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


19.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091685000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091685000&lt;/contentUpdateDate&gt;
&lt;version&gt;19.1&lt;/version&gt;
d348 4
a351 2
               if (repository.checkPath(space, -1) == SVNNodeKind.NONE)
                newSpaces.add(space);            
d362 1
@


18.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091624000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091624000&lt;/contentUpdateDate&gt;
&lt;version&gt;18.1&lt;/version&gt;
d388 1
a388 1
           def newPage = !newPages.contains(filePath);
@


17.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091490000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091490000&lt;/contentUpdateDate&gt;
&lt;version&gt;17.1&lt;/version&gt;
d339 1
d358 1
a358 1
           if (repository.checkPath(filePath, -1) == SVNNodeKind.NONE)
d360 3
d395 1
a395 1
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
@


16.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091079000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091079000&lt;/contentUpdateDate&gt;
&lt;version&gt;16.1&lt;/version&gt;
d337 2
a338 2
        def spaceList1 = new ArrayList();
        def spaceList2 = new ArrayList();
d344 5
a348 3
           if (!spaceList1.contains(space)) {
               if (repository.checkPath(space, -1) != SVNNodeKind.DIR)
                spaceList1.add(space);            
d350 9
d372 1
a372 1
           if (spaceList1.contains(space)) {
d374 1
a374 1
               spaceList1.remove(space);            
d384 2
a385 8

           def c = getFileContentAsString(space, page, language);
           def changed = false;
           if (c==null || !c.equals(xml))
             changed = true;

           if (changed) {
            if (c==null) {
d388 1
a388 1
            } else {
a391 1
            }
@


15.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271091048000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091048000&lt;/contentUpdateDate&gt;
&lt;version&gt;15.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;

import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def spaceList1 = new ArrayList();
        def spaceList2 = new ArrayList();
        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;
        def pagename2 = "";

        for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           if (!spaceList1.contains(space)) {
               if (repository.checkPath(space, -1) != SVNNodeKind.DIR)
                spaceList1.add(space);            
           }      
        }

        try {
         for (pagename in pagelist) {
           pagename2 = pagename;
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           def createDir = false;
           if (spaceList1.contains(space)) {
               createDir = true;  
               spaceList1.remove(space);            
           }  
           def xml = pagedoc.document.toFullXML(context.getContext())

           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
            filePath += "." + language;
           filePath += ".xml"


           def c = getFileContentAsString(space, page, language);
           def changed = false;
           if (c==null || !c.equals(xml))
             changed = true;

           if (changed) {
            if (c==null) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
            } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
            }
           }
         }
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        editor.closeDir();
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String space) {
        def changedList = new ArrayList();
        def list = xwiki.searchDocuments("where doc.space='${space}'")
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


14.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271091025000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271091025000&lt;/contentUpdateDate&gt;
&lt;version&gt;14.1&lt;/version&gt;
d344 1
@


13.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271090998000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271090998000&lt;/contentUpdateDate&gt;
&lt;version&gt;13.1&lt;/version&gt;
d344 1
@


12.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271090780000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271090780000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.1&lt;/version&gt;
d337 2
a338 1
        def spaceList = new ArrayList();
d342 8
a349 1
    
d351 1
a351 1
         for (def pagename in pagelist) {
a356 1

d358 3
a360 3
           if (!spaceList.contains(space)) {
               createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);  
               spaceList.add(space);            
@


11.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271090723000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271090723000&lt;/contentUpdateDate&gt;
&lt;version&gt;11.1&lt;/version&gt;
d340 1
a340 1
        def pagename = "";
d343 2
a344 1
         for (pagename in pagelist) {
d382 1
a382 1
            debug("error preparing commit on page ${pagename}: " + e.getMessage());
@


10.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271090563000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271090563000&lt;/contentUpdateDate&gt;
&lt;version&gt;10.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;
import java.util.Collection;
import java.util.Iterator;

import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.io.diff.SVNDeltaGenerator;

  

public class SVNLogReader {
    def xwiki;
    def context;
    def repurl = "";
    def defaultspace = "";
    def SVNRepository repository = null;
    def username = "";
    def password = "";
    def sdebug = "";

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
       this.repurl = configdoc.getValue("repository");
       this.defaultspace = configdoc.getValue("defaultspace");
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public setRepository(rep) {
        this.repurl = rep;
    }

    public getDefaultSpace() {
        return this.defaultspace;
    }

    public boolean initRepository() {
        /*
         * initializes the library (it must be done before ever using the
         * library itself)
         */
        setupLibrary();

        try {
            /*
             * Creates an instance of SVNRepository to work with the repository.
             * All user's requests to the repository are relative to the
             * repository location used to create this SVNRepository.
             * SVNURL is a wrapper for URL strings that refer to repository locations.
             */
            repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(repurl));
        } catch (SVNException svne) {
            /*
             * Perhaps a malformed URL is the cause of this exception
             */
            debug("Error while creating an SVNRepository for location '"
                            + repurl + "': " + svne.getMessage());
            return false;
        }
 
        /*
         * User's authentication information (name/password) is provided via  an 
         * ISVNAuthenticationManager  instance.  SVNWCUtil  creates  a   default 
         * authentication manager given user's name and password.
         * 
         * Default authentication manager first attempts to use provided user name 
         * and password and then falls back to the credentials stored in the 
         * default Subversion credentials storage that is located in Subversion 
         * configuration area. If you'd like to use provided user name and password 
         * only you may use BasicAuthenticationManager class instead of default 
         * authentication manager:
         * 
         *  authManager = new BasicAuthenticationsManager(userName, userPassword);
         *  
         * You may also skip this point - anonymous access will be used. 
         */
        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(username, password);
        repository.setAuthenticationManager(authManager);

        try {
            /*
             * Checks up if the specified path/to/repository part of the URL
             * really corresponds to a directory. If doesn't the program exits.
             * SVNNodeKind is that one who says what is located at a path in a
             * revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath("", -1);
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return false;
            } else if (nodeKind == SVNNodeKind.FILE) {
                debug("The entry at '" + repurl + "' is a file while a directory was expected.");
                return false;
            }
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return false;
        }
        return true;
     }
 

     public listFiles() {
        def str = ""
        try {
           /*
             * getRepositoryRoot() returns the actual root directory where the
             * repository was created. 'true' forces to connect to the repository 
             * if the root url is not cached yet. 
             */
            str += "Repository Root: " + repository.getRepositoryRoot(true).toString() + "\n";
            /*
             * getRepositoryUUID() returns Universal Unique IDentifier (UUID) of the 
             * repository. 'true' forces to connect to the repository 
             * if the UUID is not cached yet.
             */
            str += "Repository UUID: " + repository.getRepositoryUUID(true).toString() + "\n";

            /*
             * Displays the repository tree at the current path - "" (what means
             * the path/to/repository directory)
             */
            str += listEntries(repository, "");
            return str;
        } catch (SVNException svne) {
            debug("error while listing entries: " + svne.getMessage());
            return str;
        }
    }

    /*
     * Initializes the library to work with a repository via 
     * different protocols.
     */
    private static void setupLibrary() {
        /*
         * For using over http:// and https://
         */
        DAVRepositoryFactory.setup();
        /*
         * For using over svn:// and svn+xxx://
         */
        SVNRepositoryFactoryImpl.setup();
        
        /*
         * For using over file:///
         */
        FSRepositoryFactory.setup();
    }

    /*
     * Called recursively to obtain all entries that make up the repository tree
     * repository - an SVNRepository which interface is used to carry out the
     * request, in this case it's a request to get all entries in the directory
     * located at the path parameter;
     * 
     * path is a directory path relative to the repository location path (that
     * is a part of the URL used to create an SVNRepository instance);
     *  
     */
    public listEntries(SVNRepository repository, String path) throws SVNException {
        /*
         * Gets the contents of the directory specified by path at the latest
         * revision (for this purpose -1 is used here as the revision number to
         * mean HEAD-revision) getDir returns a Collection of SVNDirEntry
         * elements. SVNDirEntry represents information about the directory
         * entry. Here this information is used to get the entry name, the name
         * of the person who last changed this entry, the number of the revision
         * when it was last changed and the entry type to determine whether it's
         * a directory or a file. If it's a directory listEntries steps into a
         * next recursion to display the contents of this directory. The third
         * parameter of getDir is null and means that a user is not interested
         * in directory properties. The fourth one is null, too - the user
         * doesn't provide its own Collection instance and uses the one returned
         * by getDir.
         */
        def str = "";
        Collection entries = repository.getDir(path, -1, null,
                (Collection) null);
        Iterator iterator = entries.iterator();
        while (iterator.hasNext()) {
            SVNDirEntry entry = (SVNDirEntry) iterator.next();
            str += entry.getDate().toString() + ": " + path + "/" + entry.getName().toString() + " " + entry.getRevision().toString() + " \n";
           /* str += "/" + (path.equals("") ? "" : path + "/")
                    + entry.getName().toString() + " (author: '" + entry.getAuthor().toString()
                    + "'; revision: " + entry.getRevision().toString() + "; date: " + entry.getDate().toString() + ")" + "\n";
           */
            /*
             * Checking up if the entry is a directory.
             */
            if (entry.getKind() == SVNNodeKind.DIR) {
                str += listEntries(repository, (path.equals("")) ? entry.getName().toString()
                        : path + "/" + entry.getName().toString());
            }
        }
        return str;
    }

    public String getFileContentAsString(String space, String page, String language) {
      def c = getFileContent(space, page, language);
      if (c==null)
       return null;
      else
       return new String(c);
    }

    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        /*
         * This Map will be used to get the file properties. Each Map key is a
         * property name and the value associated with the key is the property
         * value.
         */
        SVNProperties fileProperties = new SVNProperties();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            /*
             * Checks up if the specified path really corresponds to a file. If
             * doesn't the program exits. SVNNodeKind is that one who says what is
             * located at a path in a revision. -1 means the latest revision.
             */
            SVNNodeKind nodeKind = repository.checkPath(filePath, -1);
            
            if (nodeKind == SVNNodeKind.NONE) {
                debug("There is no entry at '" + repurl + "'.");
                return null;
            } else if (nodeKind == SVNNodeKind.DIR) {
                debug("The entry at '" + repurl
                        + "' is a directory while a file was expected.");
                return null;
            }
            /*
             * Gets the contents and properties of the file located at filePath
             * in the repository at the latest revision (which is meant by a
             * negative revision number).
             */
            repository.getFile(filePath, -1, fileProperties, baos);

        } catch (SVNException svne) {
            System.err.println("error while fetching the file contents and properties: " + svne.getMessage());
            System.exit(1);
        }
        return baos.toByteArray();
    }

    public commitFile(pagedoc, message) {
        def c = pagedoc.document.toFullXML(context.getContext())
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def spaceList = new ArrayList();
        def editor = repository.getCommitEditor(message, null);
        def commitInfo = null;
        def pagename = "";
    
        try {
         for (pagename in pagelist) {
           def pagedoc = xwiki.getDocument(pagename);
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();

           def createDir = false;
           if (!spaceList.contains(space)) {
               createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);  
               spaceList.add(space);            
           }  
           def c = pagedoc.document.toFullXML(context.getContext())

           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;amp;&amp;amp;language!="")
            filePath += "." + language;
           filePath += ".xml"


           def c = getFileContentAsString(space, page, language);
           def changed = false;
           if (c==null || !c.equals(xml))
             changed = true;

           if (changed) {
            if (c==null) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
            } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
            }
           }
         }
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename}: " + e.getMessage());
            return null;

        } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
         }
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
        setFileContent(space, page, language, xml, message, createDir, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;amp;&amp;amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             addFile(editor, space, filePath, xml.getBytes(), createDir)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }

    /*
     * This method performs commiting an addition of a  directory  containing  a
     * file.
     */
    private void addFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] data, boolean createDir) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD (actually, for a comit  editor  this number  is 
         * irrelevant)
         */
        editor.openRoot(-1);
        /*
         * Adds a new directory (in this  case - to the  root  directory  for 
         * which the SVNRepository was  created). 
         * Since this moment all changes will be applied to this new  directory.
         * 
         * dirPath is relative to the root directory.
         * 
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd) parameter is set to  -1  since  the  directory is not added 
         * with history (is not copied, in other words).
         */
         if (createDir) {      
          editor.addDir(dirPath, null, -1);
         } else {
          editor.openDir(dirPath, -1);
         }
        /*
         * Adds a new file to the just added  directory. The  file  path is also 
         * defined as relative to the root directory.
         *
         * copyFromPath (the 2nd parameter) is set to null and  copyFromRevision
         * (the 3rd parameter) is set to -1 since  the file is  not  added  with 
         * history.
         */
        editor.addFile(filePath, null, -1);
        /*
         * The next steps are directed to applying delta to the  file  (that  is 
         * the full contents of the file in this case).
         */
        editor.applyTextDelta(filePath, null);
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, using 'base' 
         * data will result in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(data), editor, true);

        /*
         * Closes the new added file.
         */
        editor.closeFile(filePath, checksum);
        /*
         * Closes the new added directory.
         */
        editor.closeDir();
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing file modifications.
     */
    private void modifyFile(ISVNEditor editor, String dirPath,
            String filePath, byte[] oldData, byte[] newData) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Opens a next subdirectory (in this example program it's the directory
         * added  in  the  last  commit).  Since this moment all changes will be
         * applied to this directory.
         * 
         * dirPath is relative to the root directory.
         * -1 - revision is HEAD
         */
        editor.openDir(dirPath, -1);
        /*
         * Opens the file added in the previous commit.
         * 
         * filePath is also defined as a relative path to the root directory.
         */
        editor.openFile(filePath, -1);
        
        /*
         * The next steps are directed to applying and writing the file delta.
         */
        editor.applyTextDelta(filePath, null);
        
        /*
         * Use delta generator utility class to generate and send delta
         * 
         * Note that you may use only 'target' data to generate delta when there is no 
         * access to the 'base' (previous) version of the file. However, here we've got 'base' 
         * data, what in case of larger files results in smaller network overhead.
         * 
         * SVNDeltaGenerator will call editor.textDeltaChunk(...) method for each generated 
         * "diff window" and then editor.textDeltaEnd(...) in the end of delta transmission.  
         * Number of diff windows depends on the file size. 
         *  
         */
        SVNDeltaGenerator deltaGenerator = new SVNDeltaGenerator();
        String checksum = deltaGenerator.sendDelta(filePath, new ByteArrayInputStream(oldData), 0, new ByteArrayInputStream(newData), editor, true);

        /*
         * Closes the file.
         */
        editor.closeFile(filePath, checksum);

        /*
         * Closes the directory.
         */
        editor.closeDir();

        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }

    /*
     * This method performs committing a deletion of a directory.
     */
    private void deleteDir(ISVNEditor editor, String dirPath) throws SVNException {
        /*
         * Always called first. Opens the current root directory. It  means  all
         * modifications will be applied to this directory until  a  next  entry
         * (located inside the root) is opened/added.
         * 
         * -1 - revision is HEAD
         */
        editor.openRoot(-1);
        /*
         * Deletes the subdirectory with all its contents.
         * 
         * dirPath is relative to the root directory.
         */
        editor.deleteEntry(dirPath, -1);
        /*
         * Closes the root directory.
         */
        editor.closeDir();
    }


    public getChangedPages(String space) {
        def changedList = new ArrayList();
        def list = xwiki.searchDocuments("where doc.space='${space}'")
        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           def wikicontent = pagedoc.getDocument().toFullXML(context.getContext())
           def svncontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), "")
           if (!wikicontent.equals(svncontent))
            changedList.add(page)
        }
        return changedList;
    }


    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


9.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271086818000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271086818000&lt;/contentUpdateDate&gt;
&lt;version&gt;9.1&lt;/version&gt;
d331 71
d403 5
a420 1
          def createDir = (repository.checkPath(space, -1) != SVNNodeKind.DIR);
d445 1
a445 1
             commitInfo = editor.closeEdit();  
@


8.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1271085672000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271085672000&lt;/contentUpdateDate&gt;
&lt;version&gt;8.1&lt;/version&gt;
d79 1
d95 1
d112 4
@


7.1
log
@Imported from XAR
@
text
@d15 3
a17 3
&lt;date&gt;1271085629000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271085629000&lt;/contentUpdateDate&gt;
&lt;version&gt;7.1&lt;/version&gt;
d22 1
a22 1
&lt;comment&gt;Imported from XAR&lt;/comment&gt;
d130 1
a130 1
                            + url + "': " + svne.getMessage());
d162 1
a162 1
                debug("There is no entry at '" + url + "'.");
d165 1
a165 1
                debug("The entry at '" + url + "' is a file while a directory was expected.");
d307 1
a307 1
                debug("The entry at '" + url
@


6.1
log
@Imported from XAR
@
text
@d15 3
a17 3
&lt;date&gt;1271084824000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271084824000&lt;/contentUpdateDate&gt;
&lt;version&gt;2.1&lt;/version&gt;
@


5.1
log
@Imported from XAR
@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xwikidoc&gt;
&lt;web&gt;SVNCode&lt;/web&gt;
&lt;name&gt;SVNGroovy&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;&lt;/parent&gt;
&lt;creator&gt;XWiki.LudovicDubost&lt;/creator&gt;
&lt;author&gt;XWiki.LudovicDubost&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.LudovicDubost&lt;/contentAuthor&gt;
&lt;creationDate&gt;1270882076000&lt;/creationDate&gt;
&lt;date&gt;1271084741000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271084741000&lt;/contentUpdateDate&gt;
&lt;version&gt;2.1&lt;/version&gt;
&lt;title&gt;&lt;/title&gt;
&lt;template&gt;&lt;/template&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;Imported from XAR&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.0&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;object&gt;
&lt;class&gt;
&lt;name&gt;XWiki.TagClass&lt;/name&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;customMapping&gt;&lt;/customMapping&gt;
&lt;defaultViewSheet&gt;&lt;/defaultViewSheet&gt;
&lt;defaultEditSheet&gt;&lt;/defaultEditSheet&gt;
&lt;defaultWeb&gt;&lt;/defaultWeb&gt;
&lt;nameField&gt;&lt;/nameField&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;tags&gt;
&lt;cache&gt;0&lt;/cache&gt;
&lt;displayType&gt;checkbox&lt;/displayType&gt;
&lt;multiSelect&gt;1&lt;/multiSelect&gt;
&lt;name&gt;tags&lt;/name&gt;
&lt;number&gt;1&lt;/number&gt;
&lt;prettyName&gt;Tags&lt;/prettyName&gt;
&lt;relationalStorage&gt;1&lt;/relationalStorage&gt;
&lt;separator&gt; &lt;/separator&gt;
&lt;separators&gt; ,|&lt;/separators&gt;
&lt;size&gt;30&lt;/size&gt;
&lt;unmodifiable&gt;0&lt;/unmodifiable&gt;
&lt;values&gt;&lt;/values&gt;
&lt;classType&gt;com.xpn.xwiki.objects.classes.StaticListClass&lt;/classType&gt;
&lt;/tags&gt;
&lt;/class&gt;
&lt;name&gt;SVNCode.SVNGroovy&lt;/name&gt;
&lt;number&gt;0&lt;/number&gt;
&lt;className&gt;XWiki.TagClass&lt;/className&gt;
&lt;guid&gt;e74e9501-16d5-4622-a16c-55bb96ac61e1&lt;/guid&gt;
&lt;property&gt;
&lt;tags/&gt;
&lt;/property&gt;
&lt;/object&gt;
&lt;content&gt;import java.text.SimpleDateFormat

public class SVNLogReader {
    def xwiki;
    def context;
    def repository = "";
    def username = "";
    def password = "";
    def svnCmd = "/usr/bin/svn"
    def svnCmd2 = "/usr/bin/svnxml.sh"
    def lastCmd = ""
    def lastResult = ""
    def datefmt = new SimpleDateFormat("yyyy-MM-dd")
    def timefmt = new SimpleDateFormat("HH:mm:ss")
    def dtparser = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm z")

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public setSVNConfig(page) {
       def configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").getProperty("password").property.value
    }

    public getLastCommand() {
      return lastCmd;
    } 

    public getLastResult() {
      return lastResult;
    } 

    public setRepository(rep) {
        repository = rep;
    }
   
    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
        def res = []
        def cmd = svnCmd2 + " " + date + " " + hour + " " + repository + "/" + dir;             
        lastCmd = cmd
        def xml = cmd.execute().getText();  
        lastResult = xml;
        def root = new XmlParser().parseText(xml)
        for (logentry in root.logentry) {
            if (logentry.paths.size()&amp;gt;0) {  
            for (path in logentry.paths.get(0)) {
                def dt = dtparser.parse(logentry.date.text().substring(0,16) + " UTC")
                def pathinfo = [
                    rev: logentry.attribute("revision"),
                    author: logentry.author.text(),
                    date: datefmt.format(dt),
                    time: timefmt.format(dt),
                    msg: logentry.msg.text(),
                    path: new String(path.text().getBytes(),"UTF-8"),
                    action: path.attribute("action")
                ]
                res.add(pathinfo)
               }
            }
        }
        return (res)
    }

    public getModifiedFiles(dir, rev, max) {
        def res = []
        def cmd = svnCmd;
        cmd += " log -v" 
        if (username!="")
         cmd += " " + "--username ${username} --password ${password}"
 
        cmd += " " + "--xml" \
        + " " + (max == "" ? "" : "--limit " + max) \
        + " " + (rev == "" ? "" : "-r " + rev + "") \
        + " " + repository + "/" + dir
                
        lastCmd = cmd
        def xml = cmd.execute().getText();  
        lastResult = xml;
        def root = new XmlParser().parseText(xml)
        for (logentry in root.logentry) {
            if (logentry.paths.size()&amp;gt;0) {  
            for (path in logentry.paths.get(0)) {
                def dt = dtparser.parse(logentry.date.text().substring(0,16) + " UTC")
                def pathinfo = [
                    rev: logentry.attribute("revision"),
                    author: logentry.author.text(),
                    date: datefmt.format(dt),
                    time: timefmt.format(dt),
                    msg: logentry.msg.text(),
                    path: new String(path.text().getBytes(),"UTF-8"),
                    action: path.attribute("action")
                ]
                res.add(pathinfo)
               }
            }
        }
        return (res)
    }
    public getRevisions(dir) {
        def res = []
        def cmd = svnCmd + " log -v --xml" \
        + " " + repository + "/" + dir
                
        lastCmd = cmd
        def xml = cmd.execute().getText()
        def root = new XmlParser().parseText(xml)
        for (logentry in root.logentry) {
            def revinfo = [
                rev: logentry.attribute("revision"),
                author: logentry.author.text(),
                date: logentry.date.text().substring(0,10),
                time: logentry.date.text().substring(11,16),
                msg: logentry.msg.text(),
            ]
            res.add(revinfo)
        }
        return (res)
    }
    
    public listFiles(dir, recursive) {
        def res = [];
        def cmd = svnCmd + " ls --xml" \
        + " " + (recursive == true ? "-R" : "") \
        + " " + repository + "/" + dir
        
        def xml = cmd.execute().getText()
        def root = new XmlParser().parseText(xml)
        for (entry in  root.list[0]) {
            def fileinfo = [
                rev: entry.commit[0].attribute("revision"),
                author: entry.commit[0].author.text(),
                date: entry.commit.date[0].text().substring(0,10),
                time: entry.commit.date[0].text().substring(11,16),
                kind: entry.attribute("kind"),
                name: entry.name.text(),
                size: entry.size.text()
            ]
            res.add(fileinfo)
        }
        return (res)
    }
}

&lt;/content&gt;&lt;/xwikidoc&gt;@


4.1
log
@Imported from XAR
@
text
@d15 2
a16 2
&lt;date&gt;1271084684000&lt;/date&gt;
&lt;contentUpdateDate&gt;1271084684000&lt;/contentUpdateDate&gt;
@


3.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1270882839000&lt;/date&gt;
&lt;contentUpdateDate&gt;1270882839000&lt;/contentUpdateDate&gt;
&lt;version&gt;3.1&lt;/version&gt;
d22 1
a22 1
&lt;comment&gt;&lt;/comment&gt;
@


2.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1270882656000&lt;/date&gt;
&lt;contentUpdateDate&gt;1270882656000&lt;/contentUpdateDate&gt;
&lt;version&gt;2.1&lt;/version&gt;
d84 1
a84 1
       this.password = configdoc.getObject("SVNCode.SVNConfigClass").get("password").property.value
@


1.1
log
@@
text
@d15 3
a17 3
&lt;date&gt;1270882256000&lt;/date&gt;
&lt;contentUpdateDate&gt;1270882256000&lt;/contentUpdateDate&gt;
&lt;version&gt;1.1&lt;/version&gt;
d84 1
a84 1
       this.password = configdoc.getValue("password")
d136 6
a141 1
        def cmd = svnCmd + " log -v --xml" \
@
</versions></xwikidoc>